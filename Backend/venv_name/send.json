{
    "smart_contract_code": "pragma solidity ^0.8.0;\n\ncontract SocialMedia {\n    // Structure to represent a story\n    struct Story {\n        uint256 id;\n        string content;\n        address author;\n        uint256 likes;\n        uint256 comments;\n        uint256 shares;\n    }\n\n    // Mapping from story ID to Story struct\n    mapping(uint256 => Story) public stories;\n    //Variable to keep track of the next story ID\n    uint256 public nextStoryId = 1;\n\n    // Function to post a new story\n    function postStory(string memory _content) public {\n        stories[nextStoryId] = Story(nextStoryId, _content, msg.sender, 0, 0, 0);\n        nextStoryId++;\n    }\n\n    // Function to like a story\n    function likeStory(uint256 _storyId) public {\n        require(_storyId > 0 && _storyId < nextStoryId, \"Invalid story ID\");\n        stories[_storyId].likes++;\n    }\n\n    // Function to comment on a story (simple counter for now)\n    function commentStory(uint256 _storyId) public {\n        require(_storyId > 0 && _storyId < nextStoryId, \"Invalid story ID\");\n        stories[_storyId].comments++;\n    }\n\n    // Function to share a story (simple counter for now)\n    function shareStory(uint256 _storyId) public {\n        require(_storyId > 0 && _storyId < nextStoryId, \"Invalid story ID\");\n        stories[_storyId].shares++;\n    }\n\n    // Function to get story details\n    function getStory(uint256 _storyId) public view returns (Story memory) {\n        require(_storyId > 0 && _storyId < nextStoryId, \"Invalid story ID\");\n        return stories[_storyId];\n    }\n}",
    "explanation": "This contract allows users to post stories, like, comment, and share them. Let's break it down block by block:\n\n1. `pragma solidity ^0.8.0;`: This line specifies the Solidity compiler version.\n\n2. `contract SocialMedia { ... }`: This defines a contract named `SocialMedia`, which encapsulates the code.\n\n3. `struct Story { ... }`: This defines a structure named `Story` to store story data (ID, content, author, likes, comments, shares).\n\n4. `mapping(uint256 => Story) public stories;`: This creates a mapping to store stories.  The key is the story ID (a number), and the value is the Story struct.\n\n5. `uint256 public nextStoryId = 1;`: This variable keeps track of the next available story ID, starting from 1.\n\n6. `function postStory(string memory _content) public { ... }`: This function allows users to post new stories. It creates a new `Story` struct with the provided content, the sender's address, and initializes likes, comments, and shares to 0. It then increments `nextStoryId`.\n\n7. `function likeStory(uint256 _storyId) public { ... }`: This function increments the `likes` counter of a specific story.  The `require` statement checks if the story ID is valid.\n\n8. `function commentStory(uint256 _storyId) public { ... }`: This function increments the `comments` counter of a specific story.  It also includes a `require` statement for input validation.\n\n9. `function shareStory(uint256 _storyId) public { ... }`: This function increments the `shares` counter of a specific story. It also has a `require` statement for input validation.\n\n10. `function getStory(uint256 _storyId) public view returns (Story memory) { ... }`: This function returns the details of a specific story.  The `view` keyword indicates it doesn't modify the contract's state, and `returns (Story memory)` specifies the return type.\n\nEach function includes input validation using `require` to prevent errors from invalid story IDs.  The contract uses simple counters for likes, comments, and shares.  More sophisticated features could be added (e.g., individual user likes, comment text storage). Remember that storing large amounts of string data directly in the contract can be expensive; for a real-world application, consider using IPFS or similar for larger content."
}